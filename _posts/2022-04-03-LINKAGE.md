---
layout: post
title: "Teaching Rigid Structures How to Draw Fluidic Shapes"
subtitle: "Exploring the application of a genetic algorith to grow a population of linkge structures whose traces approximate a provided set of parametric curves.  "
date: 2022-04-03 18:00:00 -0400
background: '/img/posts/linkages_drawing_heart.png'
---

![png](/img/posts/linkage/example_linkage.png)

# Overview:

I created a library of functions which creates and manipulates linkage structures, some examples above. Each linkage structure is defined as a collection of quads, with each quad a four dimensional vector with elements representing the lengths of a simple quad-linkage. Upon fixing one terminal anchor point and articulating the other anchor point, each linkage structure draws its' own unique trace. In this project, I developed a method of "growing" linkage structures which produce a provided trace.

# Results:

The input was a collection of points which when plotted draw a heart, and the output was two linkage structures whose traces together draw a heart! However, the code is capable of taking any number of traces from which linkage structures can be grown to approximate them. Below is an example output. You can find a link to the repo where I maintain this code [here](). 

![png](/img/posts/linkage/linkageheart1.png)
![png](/img/posts/linkage/linkageheart2.png)
![png](/img/posts/linkage/linkageheart3.png)

# Code Walkthrough:

Below is just the library of functions I created in order to efficiently grown traces. The first few methods deal with computing the operating range of any general linkage structure, since when we create linkage structures at random, there is no guarantee that the trace will be well defined. 

```c#
import numpy as np
import matplotlib.pyplot as plt
import intervals as I

from pylab import rcParams

from numba import njit
from functools import partial

plt.rcParams['animation.ffmpeg_path'] = '/usr/bin/ffmpeg'
rcParams['figure.figsize'] = 15, 15

"""
A set of functions that allow us to instantiate linkages, as well as 
draw the traces for those linkages. 
"""

def F_L(t, L, tol = 1e-5):
    l1, l2, l3, l4 = L[0], L[1], L[2], L[3]
    tp2 = l4**2 + l3**2 - ((l4*l3*(l1**2 + l2**2 - t**2))/(l1*l2))
    
    #edge cases 
    if t <= np.abs(l1-l2)+tol:
        return np.abs(l3-l4)
    if t >= l2+l1-tol:
        return l3+l4
    
    return np.sqrt(tp2)

def F_inv_L(t, L):
    #inverse of F_L is the same as a tower with rotated lengths
    l1, l2, l3, l4 = L
    
    return F_L(t, L = [l4, l3, l2, l1])

def down(L):
    l1, l2, _, _ = L
    return [abs(l1 - l2), l1+l2]

def up(L):
    _ , _, l3, l4 = L
    return [abs(l3 - l4), l3+l4]

def intersection(A, B):
    """
    Returns the intersection of A and B (subsets of the real numbers)
    """
    AcapB = I.closed(A[0], A[1]) & I.closed(B[0], B[1])
    
    if AcapB.lower == I._PInf():
        return None #here, None indicates that the intersection is empty
    return [AcapB.lower, AcapB.upper]

def compose(f, g):
    return lambda x: f(g(x))

def get_1tow_attrs(L0):
    
    T = down(L0)
    FF = partial(F_L, L = L0)
    Tpp = up(L0)
    FpFp = partial(F_inv_L, L = L0)
                   
    return {"T":T, 
            "Tpp":Tpp, 
            "FF":FF,
            "FpFp":FpFp}

def align_attr(attr0, attr1):
    try:
        k = intersection(attr0["Tpp"], attr1["T"])
        T = [attr0["FpFp"](k[0]), attr0["FpFp"](k[1])]
    except TypeError:
        return None
    
    FpFp = compose(attr0["FpFp"], attr1["FpFp"])
    
    FF = compose(attr1["FF"], attr0["FF"])
    
    Tpp = [FF(T[0]), FF(T[1])]
    
    return {"T":T, 
            "Tpp":Tpp, 
            "FF":FF,
            "FpFp":FpFp}

    
def get_t(lengths):
    
    attrs = [get_1tow_attrs(L) for L in lengths]
    
    while len(attrs)>1:
        new_attrs = []
        for i in range(0, len(attrs)-1, 2):
            new_attrs.append(align_attr(attrs[i], attrs[i+1]))
        attrs = new_attrs
        
    try:
        return attrs[0]["T"]
    except TypeError:
        return None


def norm(x, y):
    return np.sqrt(x**2 + y**2)

@njit
def get_tri(p0, p1, l0, l1):
    '''
    a basic way to solve for the final coordinate of a triangle defined by SSS
    
    p1, p2 are numpy arrays representing the 2D location of the
    points of the linkage. 
    
    l1, l2 are the side lengths in question
    
    Returns the left-handed solution to the triangle problem, 
    if the solution doesn't exist, then it will return none.
    '''
    
    # if (type(p0) == type(None)) or (type(p1) == type(None)):
    #     return None
    
    x0, y0 = p0[0], p0[1]
    x1, y1 = p1[0], p1[1]
    
    d = np.sqrt((x0 - x1)**2 +  (y0 - y1)**2)
    
    if d > l0 + l1:
        return None
    
    a = (l0**2 - l1**2 + d**2)/(2*d)
    h = np.sqrt(l0**2 - a**2)
    
    x2 = x0 + a*(x1 - x0)/d
    y2 = y0 + a*(y1 - y0)/d
    
    x3 = x2 - h*(y1 - y0)/d
    y3 = y2 + h*(x1 - x0)/d
    
    return np.asarray([x3, y3])


def get_quad(p0, p1, L):
    """
    p0, p1 are the anchor points
    
    L is a list of four lengths. 
    
    This basically just makes the scissor shaped thing
    """
    l0, l1, l2, l3 = L[0], L[1], L[2], L[3]
    pC = get_tri(np.array(p0), np.array(p1), l0, l1)
    
    norm_p1_pC = (pC-p1) / norm(pC[0] - p1[0], pC[1] - p1[1])
    norm_p0_pC = (pC-p0) / norm(pC[0] - p0[0], pC[1] - p0[1])
    
    p2 = (norm_p0_pC*(l0+l2)) + p0
    p3 = (norm_p1_pC*(l1+l3)) + p1

    return p2, p3

def get_tower(lengths, p0 = [0, 0], p1 = None):
    
    try:
        T = get_t(lengths)
    except:
        return None
    
    if T is None:
        return None
    
    t = np.abs(T[0] - T[1])
    
    D = down(lengths[0])
    d = np.abs(D[0] - D[1])

    #note T is a subset of D
    if t/d < 0.01:
        return None
    
    if type(p1) == type(None):
        p1 = [0.5*(T[0]+T[1]), 0]
    
    try:
        p2, p3 = get_quad(p0, p1, lengths[0])
    except:
        return None
    
    tower_verts = [p0, p1, p2, p3]
    
    if (type(p2) == type(None)) or (type(p3) == type(None)):
        return None
    
    for i, L in enumerate(lengths[1:]):
        if (type(p2) == type(None)) or (type(p3) == type(None)):
            return None
        
        if i%2 == 0:
            try:
                p3, p2 = get_quad(p3, p2, L)
            except:
                return None
        else:
            try:
                p2, p3 = get_quad(p2, p3, L)
            except:
                return None
        
        tower_verts.append(p2)
        tower_verts.append(p3)
    
    
    tower_verts.append(get_tri((tower_verts[-1], 
                                tower_verts[-2])[len(lengths)%2 == 0], 
                               (tower_verts[-2], 
                                tower_verts[-1])[len(lengths)%2 == 0], 
                               lengths[-1][-2], 
                               lengths[-1][-1]))

    return np.asarray(tower_verts)


def disp_tower(tower):
    tower_verts = get_tower(tower)
    #takes the vertices of a tower generated by get_tower
    if type(tower_verts) == type(None):
        return None
    
    y_points, x_points = tower_verts[:, 1], tower_verts[:, 0]
    y_points, x_points = np.append(y_points, y_points[-1]), np.append(x_points, x_points[-1])
    
    A0, A1 = tower_verts[1][::-1], tower_verts[0][::-1]
    
    c1 = [(False, True)[((i%4 == 3) ^ (i%4 == 1))] for i in range(len(x_points))]
    c2 = [(False, True)[((i%4 == 2) ^ (i%4 == 0))] for i in range(len(x_points))]
    
    plt.scatter(x_points, y_points, s = 100)
    plt.scatter([A0[1], A1[1]], [A0[0], A1[0]], s = 100)
    plt.plot(x_points[c2], y_points[c2])
    plt.plot(x_points[c1], y_points[c1])
    plt.axis("scaled")
    plt.axis("square")

def get_trace(lengths, num_samples = 800, p0 = [0, 0]):
    try:
        T = get_t(lengths)
    except:
        return None
    
    if T is None:
        return None
    
    points = []
    for d in np.linspace(T[0]+0.0001, T[1]-0.0001, num_samples):
        try:
            tow = get_tower(lengths, 
                            p0 = p0, 
                            p1 = [d, 0])
            points.append(tow[-1])
            
        except:
            return np.array(points)
        

def disp_trace(trace,
               label = '',
               cmap = 'winter', 
               alpha = 1):
    
    if trace is not None:
        plt.scatter(trace[:, 0], 
                    trace[:, 1], 
                    c = np.linspace(0, 1, num = len(trace)),
                    label = label,
                    cmap = cmap, 
                    alpha = alpha,
                    s = 2)
        if label != '':
            plt.colorbar(label = label)

def disp_traces(traces, 
                label = '',
                cmap = 'winter'):
    
    for trace in traces:
        disp_trace(trace, 
                   label = '',
                   cmap = 'winter')
        

def disp_result(tower):
    trace = get_trace(tower)
    
    disp_trace(trace)
    disp_tower(tower)
```

